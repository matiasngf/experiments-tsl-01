---
description: How to setup TSL postprocessing with React Three Fiber and WebGPURenderer, including hooks and performance patterns.
alwaysApply: false
---

# TSL Postprocessing with React Three Fiber

This guide covers setting up TSL postprocessing in React Three Fiber projects using WebGPURenderer.

## Setup Requirements

### Dependencies

```bash
pnpm add three @react-three/fiber
```

### WebGPU Renderer Setup

React Three Fiber needs to be configured to use WebGPURenderer:

```tsx
import { Canvas } from "@react-three/fiber";
import * as THREE from "three/webgpu";

function App() {
  return (
    <Canvas
      gl={async (props) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const renderer = new WebGPURenderer(props as any);
        await renderer.init();
        return renderer;
      }}
    >
      <Suspense fallback={null}>
        <Scene />
      </Suspense>
    </Canvas>
  );
}
```

---

## Basic Postprocessing Hook

Create a custom hook to manage postprocessing:

```tsx
// hooks/use-postprocessing.ts
import { useThree, useFrame } from "@react-three/fiber";
import { useEffect, useRef } from "react";
import * as THREE from "three/webgpu";
import { pass } from "three/tsl";
import { bloom } from "three/addons/tsl/display/BloomNode.js";

export function usePostprocessing() {
  const { gl, scene, camera } = useThree();
  const postProcessingRef = useRef<THREE.PostProcessing | null>(null);

  useEffect(() => {
    const postProcessing = new THREE.PostProcessing(gl as THREE.WebGPURenderer);

    const scenePass = pass(scene, camera);
    const scenePassColor = scenePass.getTextureNode("output");

    const bloomPass = bloom(scenePassColor, 1, 0.4, 0.5);
    postProcessing.outputNode = scenePassColor.add(bloomPass);

    postProcessingRef.current = postProcessing;

    return () => {
      postProcessing.dispose();
    };
  }, [gl, scene, camera]);

  useFrame(() => {
    postProcessingRef.current?.render();
  }, 1); // Priority 1 to run after scene updates

  return postProcessingRef;
}
```

### Usage

```tsx
function Scene() {
  usePostprocessing();

  return (
    <>
      <mesh>
        <boxGeometry />
        <meshStandardMaterial color="hotpink" />
      </mesh>
      <ambientLight intensity={0.5} />
    </>
  );
}
```

---

## Configurable Postprocessing Hook

For dynamic effect parameters:

```tsx
// hooks/use-bloom-pass.ts
"use client";

import { useMemo } from "react";
import { uniform } from "three/tsl";
import { bloom } from "three/addons/tsl/display/BloomNode.js";
import type { Node, PassNode } from "three/webgpu";

interface BloomPassOptions {
  /** Bloom strength/intensity (default: 1) */
  strength?: number;
  /** Bloom radius - size of the bloom effect (default: 0.5) */
  radius?: number;
  /** Bloom threshold - values below this won't bloom (default: 0.5) */
  threshold?: number;
}

interface BloomUniforms {
  strength: ReturnType<typeof uniform<number>>;
  radius: ReturnType<typeof uniform<number>>;
  threshold: ReturnType<typeof uniform<number>>;
}

interface BloomPassResult {
  /** The bloom node to add to the scene color */
  bloomNode: Node;
  /** Uniforms for direct access */
  uniforms: BloomUniforms;
}

/**
 * Hook that creates a bloom postprocessing pass with reactive parameters.
 *
 * @param scenePass - The scene pass from usePostProcessing
 * @param options - Bloom configuration options
 *
 * @example
 * ```tsx
 * const { postProcessing, scenePass } = usePostProcessing();
 * const { bloomNode } = useBloomPass(scenePass, {
 *   strength: 1.5,
 *   threshold: 0.3,
 *   radius: 0.5,
 * });
 *
 * useEffect(() => {
 *   const sceneColor = scenePass.getTextureNode('output');
 *   postProcessing.outputNode = renderOutput(sceneColor.add(bloomNode));
 * }, [postProcessing, scenePass, bloomNode]);
 * ```
 */
export function useBloomPass(
  scenePass: PassNode,
  options: BloomPassOptions = {}
): BloomPassResult {
  const { strength = 1, radius = 0.5, threshold = 0.5 } = options;

  const [bloomNode, uniforms] = useMemo(() => {
    const uniforms: BloomUniforms = {
      strength: uniform(strength),
      radius: uniform(radius),
      threshold: uniform(threshold),
    };

    const sceneColor = scenePass.getTextureNode("output");

    const bloomNode = bloom(
      sceneColor,
      uniforms.strength as unknown as number,
      uniforms.radius as unknown as number,
      uniforms.threshold as unknown as number
    );

    return [bloomNode, uniforms] as const;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scenePass]);

  // Update uniforms directly - no useEffect needed
  uniforms.strength.value = strength;
  uniforms.radius.value = radius;
  uniforms.threshold.value = threshold;

  return { bloomNode, uniforms };
}
```

Usage:

```tsx
  const { postProcessing, scenePass } = usePostProcessing();

  const { bloomNode } = useBloomPass(scenePass, {
    strength: 0.7,
    threshold: 0.5,
    radius: 0.2,
  });

  // Chain postprocessing passes
  useEffect(() => {
    const sceneColor = scenePass.getTextureNode("output");
    postProcessing.outputNode = renderOutput(sceneColor.add(bloomNode));
  }, [postProcessing, scenePass, bloomNode]);

```

### Usage with Leva Controls

```tsx
import { useControls } from "leva";

function Scene() {
  const { postEnabled } = useControls({
    postEnabled: {
      value: true,
      label: "PostProcessing",
    },
  });
  const { postProcessing, scenePass } = usePostProcessing({
    enabled: postEnabled,
  });

  return <SceneContent />;
}
```

## Performance Best Practices

### 1. Use Uniforms for Dynamic Values

```tsx
// ✅ Good - updates uniform, no shader recompilation
uniforms.strength.value = newValue;

// ❌ Bad - recreates entire postprocessing chain
useEffect(() => {
  const bloomPass = bloom(scenePass, strength, threshold, radius);
}, [strength]); // Re-runs on every strength change
```

### 2. Memoize Uniform Objects

```tsx
// ✅ Good - uniforms created once
const uniforms = useMemo(
  () => ({
    strength: uniform(1),
  }),
  []
);

// ❌ Bad - new uniform on every render
const uniforms = {
  strength: uniform(strength),
};
```

### 3. Separate Graph Structure from Values

```tsx
// Structure changes → recreate graph
useEffect(() => {
  // Build postprocessing chain
}, [enableBloom, enableFXAA]); // Only when features toggle

// Value changes → update uniforms
useEffect(() => {
  uniforms.strength.value = strength;
}, [strength]); // Fast update
```

### 4. Use Resolution Scaling

```tsx
const scenePass = pass(scene, camera);
scenePass.setResolutionScale(0.5); // Render at half res for performance
```

### 5. Dispose on Unmount

```tsx
useEffect(() => {
  return () => {
    postProcessing.dispose();
    bloomPass.dispose?.();
  };
}, []);
```

---

## Common Patterns

### Animate Uniforms with useFrame

```tsx
useFrame((state) => {
  uniforms.time.value = state.clock.elapsedTime;
  uniforms.strength.value = Math.sin(state.clock.elapsedTime) * 0.5 + 0.5;
});
```

### Conditional Effects

```tsx
useEffect(() => {
  let outputNode = scenePassColor;

  if (enableBloom) {
    outputNode = outputNode.add(bloom(outputNode, ...));
  }

  if (enableVignette) {
    outputNode = vignette(outputNode, ...);
  }

  postProcessing.outputNode = outputNode;
  postProcessing.needsUpdate = true; // Required when graph changes
}, [enableBloom, enableVignette]);
```

### Access Depth Buffer

```tsx
const scenePass = pass(scene, camera);
const colorTexture = scenePass.getTextureNode('output');
const depthTexture = scenePass.getTextureNode('depth');

// Use for depth-based effects
const dofPass = dof(colorTexture, scenePass.getViewZNode(), ...);
```

---

## Key Takeaways

1. **Create uniforms once with `useMemo`** - Never recreate on prop changes
2. **Update `.value` for dynamic parameters** - Avoids shader recompilation
3. **Use `useFrame` priority** - Render postprocessing after scene updates
4. **Dispose resources in cleanup** - Prevent WebGPU memory leaks
5. **Separate structure from values** - Only recreate graph when effects toggle
6. **Mind effect ordering** - Linear space effects before tone mapping, AA last
